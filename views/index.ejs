<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Snake ‚Äî Fixed overlay + realistic snake</title>
<style>
  :root{ --accent:#28a745; }
  html,body{height:100%; margin:0}
  body{
    display:flex; align-items:center; justify-content:center;
    background: linear-gradient(135deg,#283048,#859398);
    font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial;
    color:#fff; padding:18px;
  }
  .frame { text-align:center; display:inline-block; }
  h1{ margin:8px 0 12px; font-size:20px; }

  #gameContainer{ position:relative; display:inline-block; line-height:0; border-radius:12px; overflow:visible; }
  canvas{ display:block; image-rendering: optimizeSpeed; }

  /* overlay (start / game over) */
  #overlay{
    position:absolute; inset:0;
    display:flex; align-items:center; justify-content:center; flex-direction:column;
    background: rgba(0,0,0,0.70); gap:8px; z-index:20; font-size:18px; border-radius:12px;
    padding:10px; box-sizing:border-box;
  }
  #overlayTitle{ font-size:20px; font-weight:700; }
  #overlaySub{ font-size:15px; opacity:0.95; }
  .controls { margin-top:14px; display:flex; gap:10px; justify-content:center; }
  button{
    background: rgba(255,255,255,0.08);
    border: 1px solid rgba(255,255,255,0.12);
    color:#fff; padding:8px 14px; border-radius:8px; cursor:pointer; font-weight:600;
  }
  button.primary { background: linear-gradient(90deg,var(--accent),#24a743); border:none; color:#04240b; }
  #score { text-align:center; margin-top:10px; font-weight:600; color:#e8f5e9; }
  @media (max-width:560px){ body{padding:8px} canvas{width:96vw; height:auto} }
</style>
</head>
<body>
  <div class="frame">
    <h1>üêç Realistic Snake Game</h1>

    <div id="gameContainer">
      <canvas id="gameCanvas"></canvas>

      <div id="overlay">
        <div id="overlayTitle">üéÆ Ready to play?</div>
        <div id="overlaySub"></div>
        <button id="overlayBtn" class="primary">Start Game</button>
      </div>
    </div>

    <div class="controls">
      <button id="playBtn">‚ñ∂ Play</button>
      <button id="pauseBtn">‚è∏ Pause</button>
      <button id="restartBtn">üîÑ Restart</button>
    </div>

    <div id="score">Score: 0</div>
  </div>

<script>
(() => {
  // CONFIG (change TOTAL_W/H or TILE for size)
  const TOTAL_W = 450, TOTAL_H = 450, TILE = 25, INNER_PADDING = 12;
  const START_SPEED = 200, MIN_SPEED = 60, SPEED_STEP = 8;

  // DOM
  const canvas = document.getElementById('gameCanvas');
  const container = document.getElementById('gameContainer');
  const ctx = canvas.getContext('2d');
  const overlay = document.getElementById('overlay');
  const overlayTitle = document.getElementById('overlayTitle');
  const overlaySub = document.getElementById('overlaySub');
  const overlayBtn = document.getElementById('overlayBtn');
  const playBtn = document.getElementById('playBtn');
  const pauseBtn = document.getElementById('pauseBtn');
  const restartBtn = document.getElementById('restartBtn');
  const scoreEl = document.getElementById('score');

  // Canvas + play area sizing
  canvas.width = TOTAL_W; canvas.height = TOTAL_H;
  container.style.width = canvas.width + 'px';
  container.style.height = canvas.height + 'px';

  const availW = canvas.width - INNER_PADDING * 2;
  const availH = canvas.height - INNER_PADDING * 2;
  const COLS = Math.floor(availW / TILE);
  const ROWS = Math.floor(availH / TILE);
  const playW = COLS * TILE, playH = ROWS * TILE;
  const playOffsetX = INNER_PADDING + Math.floor((availW - playW) / 2);
  const playOffsetY = INNER_PADDING + Math.floor((availH - playH) / 2);

  // State (grid coords)
  let snake = [], dir = {x:1,y:0}, nextDir = {x:1,y:0}, food = null;
  let score = 0, speed = START_SPEED, timer = null, running = false;

  function updateScore(){ scoreEl.textContent = 'Score: ' + score; }

  function placeFood(){
    let f, tries=0;
    do {
      f = { x: Math.floor(Math.random()*COLS), y: Math.floor(Math.random()*ROWS) };
      tries++; if (tries>2000) break;
    } while (snake.some(s => s.x===f.x && s.y===f.y));
    return f;
  }

  function initState(){
    snake = [{ x: Math.floor(COLS/2), y: Math.floor(ROWS/2) }];
    dir = {x:1,y:0}; nextDir = {x:1,y:0};
    food = placeFood();
    score = 0; speed = START_SPEED; running = false;
    clearInterval(timer); updateScore(); draw();
    overlayTitle.textContent = 'üéÆ Ready to play?';
    overlaySub.textContent = '';
    overlayBtn.textContent = 'Start Game';
    overlay.style.display = 'flex';
  }

  // Drawing helpers
  function roundedRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  function drawFrameAndBackground(){
    const g = ctx.createLinearGradient(0,0,canvas.width,canvas.height);
    g.addColorStop(0,'#0f0f0f'); g.addColorStop(1,'#2a2a2a');
    ctx.fillStyle = g; ctx.fillRect(0,0,canvas.width,canvas.height);

    const boxX = playOffsetX - 6, boxY = playOffsetY - 6, boxW = playW + 12, boxH = playH + 12;
    ctx.fillStyle = 'rgba(0,0,0,0.35)'; roundedRect(boxX,boxY,boxW,boxH,12); ctx.fill();
    ctx.fillStyle = '#101214'; roundedRect(playOffsetX,playOffsetY,playW,playH,8); ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.04)'; ctx.lineWidth = 2; roundedRect(playOffsetX,playOffsetY,playW,playH,8); ctx.stroke();

    // small title bar above playfield
    ctx.fillStyle = 'rgba(255,255,255,0.03)';
    ctx.fillRect(playOffsetX, playOffsetY - 34, playW, 28);
    ctx.fillStyle = '#cfeee0';
    ctx.font = '14px system-ui, Arial';
    ctx.textAlign = 'left';
    ctx.fillText('  üêç Realistic Snake', playOffsetX + 6, playOffsetY - 14);
  }

  function drawGrid(){
    ctx.save(); ctx.translate(playOffsetX, playOffsetY);
    for(let r=0;r<ROWS;r++){
      for(let c=0;c<COLS;c++){
        ctx.fillStyle = ((r+c)%2===0) ? '#222426' : '#17181a';
        ctx.fillRect(c*TILE, r*TILE, TILE, TILE);
      }
    }
    ctx.strokeStyle = 'rgba(255,255,255,0.03)'; ctx.lineWidth = 1;
    for(let c=0;c<=COLS;c++){ ctx.beginPath(); ctx.moveTo(c*TILE+0.5,0); ctx.lineTo(c*TILE+0.5,playH); ctx.stroke(); }
    for(let r=0;r<=ROWS;r++){ ctx.beginPath(); ctx.moveTo(0,r*TILE+0.5); ctx.lineTo(playW,r*TILE+0.5); ctx.stroke(); }
    ctx.restore();
  }

  function drawFood(){
    if(!food) return;
    const px = playOffsetX + food.x * TILE;
    const py = playOffsetY + food.y * TILE;
    const cx = px + TILE/2, cy = py + TILE/2, r = TILE*0.38;
    const g = ctx.createRadialGradient(cx - r*0.2, cy - r*0.25, r*0.05, cx, cy, r);
    g.addColorStop(0, '#ffd7d7'); g.addColorStop(0.6, '#ff4d4d'); g.addColorStop(1, '#b30000');
    ctx.fillStyle = g; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill();
    // tiny stem + leaf
    ctx.strokeStyle = '#4b2c00'; ctx.lineWidth = 2;
    ctx.beginPath(); ctx.moveTo(cx, cy - r*0.6); ctx.lineTo(cx + r*0.22, cy - r*0.9); ctx.stroke();
    ctx.fillStyle = '#2ecc71'; ctx.beginPath(); ctx.ellipse(cx + r*0.33, cy - r*0.9, r*0.16, r*0.08, -0.6, 0, Math.PI*2); ctx.fill();
  }

  function drawSnake(){
    for(let i = snake.length - 1; i >= 0; i--){
      const s = snake[i];
      const px = playOffsetX + s.x * TILE;
      const py = playOffsetY + s.y * TILE;
      const cx = px + TILE/2, cy = py + TILE/2;
      const r = TILE * 0.44;
      const g = ctx.createRadialGradient(cx - r*0.12, cy - r*0.15, r*0.06, cx, cy, r);
      if(i === 0){
        g.addColorStop(0, '#bfffcf'); g.addColorStop(1, '#006400');
      } else {
        g.addColorStop(0, '#d6ffd9'); g.addColorStop(1, '#145214');
      }
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle = 'rgba(0,0,0,0.45)'; ctx.lineWidth = 1; ctx.stroke();

      // head eyes (for i==0)
      if(i === 0){
        const er = Math.max(1, r*0.12);
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(cx - r*0.25, cy - r*0.25, er, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(cx + r*0.25, cy - r*0.25, er, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#000';
        ctx.beginPath(); ctx.arc(cx - r*0.25, cy - r*0.25, er*0.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(cx + r*0.25, cy - r*0.25, er*0.5, 0, Math.PI*2); ctx.fill();
      }
    }
  }

  function draw(){ drawFrameAndBackground(); drawGrid(); drawFood(); drawSnake(); }

  // GAME logic (grid units)
  function tick(){
    if(!(nextDir.x === -dir.x && nextDir.y === -dir.y)) dir = nextDir;
    const head = snake[0];
    const nx = head.x + dir.x, ny = head.y + dir.y;

    // wall collision
    if(nx < 0 || ny < 0 || nx >= COLS || ny >= ROWS){ onGameOver(); return; }
    // self collision
    if(snake.some((p, idx) => idx > 0 && p.x === nx && p.y === ny)){ onGameOver(); return; }

    snake.unshift({ x: nx, y: ny });

    // eat?
    if(food && nx === food.x && ny === food.y){
      score++; updateScore();
      // speed up a bit
      speed = Math.max(MIN_SPEED, speed - SPEED_STEP);
      clearInterval(timer); timer = setInterval(tick, speed);
      food = placeFood();
    } else {
      snake.pop();
    }

    draw();
  }

  function onGameOver(){
    clearInterval(timer); running = false;
    overlayTitle.textContent = 'üíÄ Game Over';
    overlaySub.textContent = `Score: ${score}`;
    overlayBtn.textContent = 'Play Again';
    overlay.style.display = 'flex';
  }

  // Controls
  overlayBtn.addEventListener('click', () => {
    initState(); running = true; timer = setInterval(tick, speed); overlay.style.display = 'none';
  });
  playBtn.addEventListener('click', () => { if(!running){ initState(); running = true; timer = setInterval(tick, speed); overlay.style.display = 'none'; }});
  pauseBtn.addEventListener('click', () => { if(running){ clearInterval(timer); running = false; } else { timer = setInterval(tick, speed); running = true; overlay.style.display = 'none'; }});
  restartBtn.addEventListener('click', () => { initState(); running = true; timer = setInterval(tick, speed); overlay.style.display = 'none'; });

  window.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    if((k === 'arrowup' || k === 'w') && dir.y !== 1) nextDir = { x:0, y:-1 };
    if((k === 'arrowdown' || k === 's') && dir.y !== -1) nextDir = { x:0, y:1 };
    if((k === 'arrowleft' || k === 'a') && dir.x !== 1) nextDir = { x:-1, y:0 };
    if((k === 'arrowright' || k === 'd') && dir.x !== -1) nextDir = { x:1, y:0 };
    if(k === ' ') { if(running){ clearInterval(timer); running = false; } else { timer = setInterval(tick, speed); running = true; overlay.style.display = 'none'; } }
  });

  // initial state
  function initState(){
    snake = [{ x: Math.floor(COLS/2), y: Math.floor(ROWS/2) }];
    dir = { x:1, y:0 }; nextDir = { x:1, y:0 };
    food = placeFood(); score = 0; speed = START_SPEED; running = false;
    clearInterval(timer); updateScore(); draw();
    overlayTitle.textContent = 'üéÆ Ready to play?'; overlaySub.textContent = ''; overlayBtn.textContent = 'Start Game';
    overlay.style.display = 'flex';
  }

  initState();
})();
</script>
</body>
</html>
